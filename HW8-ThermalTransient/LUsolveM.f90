    MODULE LUsolve
    USE IntrType
!
!   This module contains some very old implementations of LINPACK
!   LU factorization/solution subroutines without reference to BLAS
!
    CONTAINS

      SUBROUTINE dgefa(a,lda,n,ipvt,info)
      IMPLICIT NONE
!
!     Declaration Generated by genImpDecs.pl 5/98
      INTEGER(sik) i,info,ip1,j,k,lda,m,n,nm1
!
!     Declaration Generated by genImpDecs.pl 5/98
      REAL(sdk) c,rp,t
!
!
!     because its name is same as routine in Cray system library.
!
!
!     dgefa factors a real matrix by gaussian elimination.
!
!     dgefa is usually called by dgeco, but it can be called
!     directly with a saving in time if  rcond  is not needed.
!     (time for dgeco) = (1 + 9/n)*(time for dgefa) .
!
!     on entry
!
!        a       real(lda, n)
!                the matrix to be factored.
!
!        lda     integer
!                the leading dimension of the array  a .
!
!        n       integer
!                the order of the matrix  a .
!
!     on return
!
!        a       an upper triangular matrix and the multipliers
!                which were used to obtain it.
!                the factorization can be written  a = l*u  where
!                l  is a product of permutation and unit lower
!                triangular matrices and  u  is upper triangular.
!
!        ipvt    integer(n)
!                an integer vector of pivot indices.
!
!        info    integer
!                = 0  normal value.
!                = k  if  u(k,k) .eq. 0.0 .  this is not an error
!                     condition for this subroutine, but it does
!                     indicate that dgesl or dgedit will divide by zero
!                     if called.  use  rcond  in dgeco for a reliable
!                     indication of singularity.
!
!     this version is written in cdc compass for the ftn compiler
!     communication convention.  results may vary slightly from those
!     obtained with a fortran version, and such a version is available
!     upon request.  this program simulates the fortran sequence..
!
!     subroutine dgefa (a, lda, n, ipvt, info)
!
      INTEGER(sik), INTENT(OUT) :: ipvt(:)
!     INTEGER(sik) ipvt(n)
!
      REAL(sdk), INTENT(INOUT) :: a(:,:)
!     REAL(sdk) a(lda,n)
!
      info=0
      IF (n.GT.1) THEN
        nm1=n-1
        DO i=1,nm1
          m=i
          ip1=i+1
          DO k=ip1,n
            IF (abs(a(k,i)).GT.abs(a(m,i))) m=k
          ENDDO
          ipvt(i)=m
          IF (a(m,i).EQ.0.d0) THEN
            info=i
          ELSE
            IF (m.NE.i) THEN
              DO k=i,n
                t=a(i,k)
                a(i,k)=a(m,k)
                a(m,k)=t
              ENDDO
            ENDIF
            rp=-1.d0/a(i,i)
            DO k=ip1,n
              a(k,i)=a(k,i)*rp
            ENDDO
            DO j=ip1,n
              c=a(i,j)
              IF (c.NE.0.d0) THEN
                DO k=ip1,n
                  a(k,j)=a(k,j)+a(k,i)*c
                ENDDO
              ENDIF
            ENDDO
          ENDIF
        ENDDO
        ipvt(n)=n
        IF (a(n,n).EQ.0.d0) info=n
      ELSE
        ipvt(1)=1
        IF (a(1,1).EQ.0.d0) info=1
      ENDIF
      RETURN
      END SUBROUTINE dgefa


      SUBROUTINE dgesl(a,lda,n,ipvt,b,job)
      IMPLICIT NONE
!
!     Declaration Generated by genImpDecs.pl 5/98
      INTEGER(sik) i,ip1,j,jm1,job,k,kb,km1,kp1,l,lda,m,n,nm1
!
!     Declaration Generated by genImpDecs.pl 5/98
      REAL(sdk) c,t
!
!
!     because its name is same as routine in Cray system library.
!
!
!     dgesl solves the real system
!     a * x = b  or  trans(a) * x = b
!     using the factors computed by dgeco or dgefa.
!
!     on entry
!
!        a       real(lda, n)
!                the output from dgeco or dgefa.
!
!        lda     integer
!                the leading dimension of the array  a .
!
!        n       integer
!                the order of the matrix  a .
!
!        ipvt    integer(n)
!                the pivot vector from dgeco or dgefa.
!
!        b       real(n)
!                the right hand side vector.
!
!        job     integer
!                = 0         to solve  a*x = b ,
!                = nonzero   to solve  trans(a)*x = b  where
!                            trans(a)  is the transpose.
!
!     on return
!
!        b       the solution vector  x .
!
!     error condition
!
!        a division by zero will occur if the input factor contains a
!        zero on the diagonal.  technically this indicates singularity
!        but it is often caused by improper arguments or improper
!        setting of lda .  it will not occur if the subroutines are
!        called correctly and if dgeco has set rcond .gt. 0.0
!        or dgefa has set info .eq. 0 .
!
!     to compute  inverse(a) * c  where  c  is a matrix
!     with  p  columns
!           call dgeco(a,lda,n,ipvt,rcond,z)
!           if (rcond is too small) go to ...
!           do 10 j = 1, p
!              call dgesl(a,lda,n,ipvt,c(1,j),0)
!        10 continue
!
!     this version is written in cdc assembly language for the ftn
!     compiler communication convention.  results may vary slightly
!     from those obtained with a fortran version, and such a version
!     is available upon request.  this program simulates the
!     following fortran sequence..
!
!     subroutine dgesl (a, lda, n, ipvt, b, job)
!
      INTEGER(sik), INTENT(IN) :: ipvt(:)
!     INTEGER(sik) ipvt(n)
!
      REAL(sdk), INTENT(INOUT) :: a(:,:),b(:)
!     REAL(sdk) a(lda,n),b(n)
!
      nm1=n-1
      IF (n.LE.1) THEN
        b(1)=b(1)/a(1,1)
      ELSEIF (job.EQ.0) THEN
        DO i=1,nm1
          m=ipvt(i)
          c=b(m)
          IF (m.NE.i) THEN
            b(m)=b(i)
            b(i)=c
          ENDIF
          IF (c.NE.0.d0) THEN
            ip1=i+1
            DO k=ip1,n
              b(k)=b(k)+a(k,i)*c
            ENDDO
          ENDIF
        ENDDO
        DO i=1,nm1
          j=n-i+1
          b(j)=b(j)/a(j,j)
          c=b(j)
          IF (c.NE.0.d0) THEN
            jm1=j-1
            DO k=1,jm1
              b(k)=b(k)-a(k,j)*c
            ENDDO
          ENDIF
        ENDDO
        b(1)=b(1)/a(1,1)
      ELSE
        DO k=1,n
          t=0.d0
          IF (k.NE.1) THEN
            km1=k-1
            DO i=1,km1
              t=t+a(i,k)*b(i)
            ENDDO
          ENDIF
          b(k)=(b(k)-t)/a(k,k)
        ENDDO
        DO kb=1,nm1
          k=n-kb
          t=0.d0
          kp1=k+1
          DO i=kp1,n
            t=t+a(i,k)*b(i)
          ENDDO
          b(k)=b(k)+t
          l=ipvt(k)
          IF (l.NE.k) THEN
            t=b(l)
            b(l)=b(k)
            b(k)=t
          ENDIF
        ENDDO
      ENDIF
      RETURN
      END SUBROUTINE dgesl

    END MODULE LUsolve
